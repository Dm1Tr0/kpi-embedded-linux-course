=============================================
Лабораторна робота №3 High-Resolution timers
=============================================

Завдання:
-------
Написати модуль ядра, який:
	* Приймає параметр *cnt* - кількість циклів, які повинен опрацювати *hr-таймер* mkdir
	* Приймає параметр *delay* - являється затримкою між двума спрацюваннями *hr-таймера*
	* Спочатку роботи модуля, він повинен надрукувати поточне значення *jiffies*
	* Після цього запускає тасклет, який повинен надрукувати власне значення *jiffies
	* init запускає *hr-таймер* з затримкою *delay* і функція завершається
	
Хід роботи
-------

Ядро ​​має два основних механізми таймера. Один з них - підсистема таймера з високою роздільною здатністю 
(або "hrtimer"), орієнтована на короткотермінові події, коли очікується, що таймер працюватиме до кінця.
Інша підсистема просто називається "таймерами ядра"; він пропонує меншу точність, але є більш ефективним 
у ситуаціях, коли таймер, ймовірно, буде скасовано до його спрацьовування. У ядрі є багато місць, де таймери 
використовуються для виявлення випадків, коли пристрій або мережевий сервер не відповідають протягом очікуваного часу; 
коли, як зазвичай, очікувана відповідь все ж відбувається, таймер скасовується. Таймери ядра добре підходять 
для такого використання

В ході виконання лабораторної роботи, було поставлене завдання використовувати таймери з високою
роздільною здатністю. Ці таймери забезпечують високу точність і управління таймерами. Вони функціонують
з гранулярністю в наносекунди і цей час представлено в спеціальному типу ktime. При роботі з hrtimers 
існує відмінність між абсолютним і відносним часом, і при виклику слід вказувати необхідний тип.

hr-таймери представлені структурою *hrtimer*. В ній визначаються компоненти таймера, які будуть необхідні
користувачеві. Вказується інформація, яка використовується для управління. Процес починається з 
ініціалізації таймера за допомогою *hrtimer_init*. В цю функцію передається ім"я таймера, визначається
тип часу(структура *clockid_t*) і режим таймера(чи буде він працювати одноразово, чи перезапускатись).

Таймер ініціалізовано і його потрібно запустити. Цей крок виконується за допомогою *hrtimer_start*. 
У цьому виклику вказується час спрацювання таймера (який ініціалізовано в *ktime_t*) і режим для значення
часу - абсолютний або відносний час. Після спрацювання таймера його роботу можна закінчити за допомогою
*hrtimer_cancel*. Ця функція буде чекати завершення функції зворотнього визову. 

В папці з змейком та програмою:

``make KBUILDDIR="~/kernel/linux-5.8.7" modules``

Далі в папці Kernel:

``qemu-system-x86_64 -m 256M -smp 4 -kernel "./bzImage" -initrd "./initramfs.cpio.gz" \ -append "console=ttyS0" -nographic \ -drive file=fat:rw:./lab3,format=raw,media=disk``

Потім:   

``mkdir /mnt``
``mount -t vfat /dev/sda1 /mnt``
``insmod /mnt/lab3.ko``
``rmmod lab3``

Результат:


.. code-block:: bash

/ # insmod /mnt/lab3.ko cnt=3 delay=1
[  101.591980] lab3: loading out-of-tree module taints kernel.
[  101.599487] Init: jiffies = 4294768809
[  101.599511] Init: called with cnt = 3, delay = 1
[  101.599900] Tasklet: jiffies = 4294768809
[  101.600823] Timer: trigger 0
[  101.601780] Timer: trigger 1
[  101.602107] insmod (94) used greatest stack depth: 13720 bytes left
[  101.602761] Timer: trigger 2
/ # rmmod lab3
[  120.447912] Exit: arr[0] = 4294768810
[  120.447943] Exit: arr[1] = 4294768811
[  120.448069] Exit: arr[2] = 4294768812
/ # insmod /mnt/lab3.ko cnt=2 delay=4
[  120.448174] Have a nice day!
[  183.737147] Init: jiffies = 4294850946
[  183.737311] Init: called with cnt = 2, delay = 4
[  183.737691] Tasklet: jiffies = 4294850947
/ # [  183.741691] Timer: trigger 0
[  183.745672] Timer: trigger 1
/ # rmmod lab3
[  189.095117] Exit: arr[0] = 4294850951
[  189.095149] Exit: arr[1] = 4294850955
/ # insmod /mnt/lab3.ko cnt=4 delay=3
[  189.095337] Have a nice day!
[  221.350162] Init: jiffies = 4294888559
[  221.350328] Init: called with cnt = 4, delay = 3
[  221.350695] Tasklet: jiffies = 4294888560
/ # [  221.353682] Timer: trigger 0
[  221.356646] Timer: trigger 1
[  221.359664] Timer: trigger 2
[  221.362644] Timer: trigger 3
/ # rmmod lab3
[  223.451698] Exit: arr[0] = 4294888563
[  223.451730] Exit: arr[1] = 4294888566
[  223.451892] Exit: arr[2] = 4294888569
[  223.452021] Exit: arr[3] = 4294888572
/ # insmod /mnt/lab3.ko cnt=15 delay=1
[  223.452172] Have a nice day!
[  256.490209] Init: jiffies = 4294923699
[  256.490369] Init: called with cnt = 15, delay = 1
[  256.490807] Tasklet: jiffies = 4294923700
[  256.491804] Timer: trigger 0
[  256.492785] Timer: trigger 1
/ # [  256.493774] Timer: trigger 2
[  256.494774] Timer: trigger 3
[  256.495773] Timer: trigger 4
[  256.496805] Timer: trigger 5
[  256.497775] Timer: trigger 6
[  256.498775] Timer: trigger 7
[  256.499783] Timer: trigger 8
[  256.500777] Timer: trigger 9
[  256.501776] Timer: trigger 10
[  256.502774] Timer: trigger 11
[  256.503773] Timer: trigger 12
[  256.504772] Timer: trigger 13
[  256.505772] Timer: trigger 14
/ # rmmod lab3
[  259.726617] Exit: arr[0] = 4294923701
[  259.726650] Exit: arr[1] = 4294923702
[  259.726817] Exit: arr[2] = 4294923703
[  259.726950] Exit: arr[3] = 4294923704
[  259.727075] Exit: arr[4] = 4294923705
[  259.727200] Exit: arr[5] = 4294923706
[  259.727337] Exit: arr[6] = 4294923707
[  259.727651] Exit: arr[7] = 4294923708
[  259.727876] Exit: arr[8] = 4294923709
[  259.728012] Exit: arr[9] = 4294923710
[  259.728134] Exit: arr[10] = 4294923711
[  259.728258] Exit: arr[11] = 4294923712
[  259.728388] Exit: arr[12] = 4294923713
[  259.728654] Exit: arr[13] = 4294923714
[  259.728784] Exit: arr[14] = 4294923715
/ # 

Висновки
-------

Зробивши висновки по виконаній роботі, можна відзначити, що *hr-таймери* є більш точними за стандартні
таймери ядра. Це випливає з того, що *hr-таймери* мають більшу роздільну здатність - наносекунди, від 
стандартних - мілісекунди. Таймери з високою роздільною здітністю, зважаючи на всі висновки, можна
використовувати для ШІМ-модуляції.
