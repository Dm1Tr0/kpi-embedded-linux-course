=============================================
Лабораторна робота №5
=============================================

Тема
------

**Workqueue**

Завдання:
-------
Написати та зібрати  власний модуль ядра, який:
	* Принимает аргументы th_val, wrk_val и jffdelay, реализует два потока и ворк (в дефолтном work queue), а также таймер (на базе timer wheel)
	* Запускает таймер и ворк
	* При срабатывании таймера проверяет текущее значение jiffies, если оно кратно th_val – остановить первый поток; иначе – таймер перезапускается через jffdelay jiffies
	* Внутри ворка проверяет текущее значение jiffies, если оно кратно wrk_val - остановить второй поток; иначе – ворк должен уснуть на jffdelay jiffies и перезапустить себя.

А також:
	* Проверить работу. Для th_val и wrk_val желательно выбирать простые числа
	* Добавить два связных списка, в которые аллоцировать и добавлять элементы со значениями jiffies которые не привели к завершению первого и второго потоков соответственно. Получается связь "таймер – 1й список – 1й поток" и  "ворк – 2й список – 2й поток"
	* При выходе из потока распечатать список
	* Внутри ворка и таймера использовать правильные аллокации для новых элементов списка, правильную синхронизацию доступа к списку
	* Предусмотреть, что пользователь может выгрузить модуль досрочно

Хід роботи
-------

**Опис виконаної роботи** 
В ході роботи було написано модуль ядра мовою С.

Більшу частину коду було взято з попередніх лабораторних робіт. Роботу з таймерами - з другої, роботу з потоками і списками - з четвертої.

Далі, після перегляду деякої літератури, було написано все, що стосується роботи з workqueue. Для створення ворку використано динамічну алокацію.

Створено параметри модуля *thread_num*, *thread_delay* та *thread_inccnt* та додано їхні описи.

Оскільки дефолтний ворк і таймери не можуть спати, то завершити потоки за допомогою *kthread_stop* не можна. Тому було додано 2 прапорці, *work_thread_flag* та *timer_thread_flag*, які встановлювались у лог. "1" у воркі і тайймері відповідно. Потоки ж у свою чергу просто крутяться у циклі *while()* і чекають поки встановляться прапорці, або буде викликано *kthread_stop()*. Далі при виході з циклю потоки виводять на екран вміст списку, сповіщують про своє завершення у терміналі і завершуються.



В *init_callback* функції лише перевіряються введені параметри на корректність, виділяється пам'ять під структури потоків і ворку, безпосереднью створюються та запускаються потоки, таймер і ворк. І виводяться до терміналу значення параметрів, з якими запущено модуль.

В *exit_callback* функції за потреби зупиняємо потоки, зупиняємо ворку і таймер, звільнюємо пам'ять. І завершаємо роботу модуля.



Тести:

.. code-block:: bash

	/mnt # insmod work.ko th_val=1
	[   42.033348] Module started with parameters:
	[   42.036793] th_val = 1
	[   42.038863] wrk_val = 11
	[   42.041199] jffdelay = 100
	[   42.041199] 
	[   42.045810] timer thread was stopped at jiffies = 4294709225
	[   42.050638] timer_thread was finished
	/mnt # [   42.668800] work thread was stopped at jiffies = 4294709848
	[   42.669793] work jiffies = 4294709224
	[   42.670591] work jiffies = 4294709328
	[   42.671382] work jiffies = 4294709432
	[   42.672165] work jiffies = 4294709536
	[   42.672950] work jiffies = 4294709640
	[   42.673725] work jiffies = 4294709744
	[   42.674265] work_thread was finished
	/mnt # rmmod work
	[   47.101416] Goodbye:)
	/mnt # 






Висновки
-------
В ході роботи я познайомився з workqueue в ядрі. Зібрав свій модуль ядра, що відповідає завданню та перевірив його працездатність.
Оскільки для таймеру *th_val* = 1, то його потік відразу ж і зупинився так як всі числа кратні одиниці. А для ворки, *wrk_val* = 11, тож йому знадобилось трохи більше часу, щоб "натрапити" на значення *jiffies*, яке кратне одинадцяти. Перевіримо кінцеве значення *jiffies* для ворку:
*4294709848 / 11 = 390428168*
Як бачимо, результат - ціле число.




