=================================================
**Лабораторна робота №1 Введення в розробку модулів ядра**
=================================================


Завдання
---------------
* Підротувати оточення для збірки ядра
* зібрати мінімальне ядро Linux
* зібрати мінімальний набір user-spae утиліт
* зібрати перший модуль ядра на запустити його на зібраному ядрі
* створити власний модуля ядра 

Хід роботи
------------------
**Налагодження середи розробки**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

для збірки ядра та емуляції ядра потрібно завантажити наступні пакети (групи пакетів):
* bsase-devel - група пакетів які використовуються системами збірки ядра 
* qemu та qemu-arch-extra - емулятор на якому буде запускатися ядро 
* bc та cpio потребуються системою зборки ядра 

.. code-block:: bash

 sudo pacman -S base-devel qemu qemu-arch-extra bc cpio

**Збірка та запуск ядра**
~~~~~~~~~~~~~~~~~~~~~~~~~~
після налагодження конфігурації ядра потрібно запустити його збірку високорівневим мейкфайлом:

.. code-block:: bash

 make -j5 vmlinux 

збірка мінімального набору user-space програм.

.. code-block:: bash

 make  CRYPT_AVAILABLE=n -jN install 

Потім потрібно налаштувати корневу директорію що була створена, а саме створити init скрипт який  запуститься по замовчуванню при запуску ядра та дві
дерикторії які будуть примонтовані після запуску ядра proc та sys. Далі потрібно створити образ з цієї директорії цей образ буде використовуватись як initramfs 
при зпуску ядра.

Після всіх вище зазначених операцій запуск ядра виглядає наступним чином:

.. code-block:: bash

 qemu-system-x86_64 -no-kvm -m 256M -smp 4 -kernel "./bzImage"\
 	-initrd "./initramfs.cpio.gz" -append "console=ttyS0" -nographic

**Теорія**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Модулі ядра становлять особливий вид об'єктів діючих в ОС GNU / Linux на базі ядра Linux. Він працюють в просторі ядра. Мають привілеїв по відношенню до userspace-
додаток. Не працюють зі стандартними бібліотеками, а також не мають  main як стандартну точку входу. У більшості випадків розробники модулів уникають роботу з FPU. 
При підключенні модуля викликається функція ініціалізації __init <function_name>, а при його видаленні - __exit <function_name> Для декларації цих функцій потрібно 
використовувати module_init (name_of_init_func) і module_exit (name_of_exit_func). Для функціонування модуля потрібно вказати його лінцензію за допомогою спеціального макросу,
 а за бажанням і автора, опис, версію і т.д.

Окремоїкремої уваги заслуговує глобальна змінна jiffies, в якій міститься кількість імпульсів системного таймера, які були отримані з часу завантаження системи. 
Під час початкового завантаження ядро ​​обнуляє значення цього параметра.При кожному перериванні системного таймера він буде збільшуватися на одиницю. 
Оскільки кожну секунду виникає HZ переривань від системного таймера, за секунду значення змінної jiffies збільшується на HZ.

Тип змінної jiffies оголошений як unsigneg long, який на 64-х розрядних архітектур є 64 біта, а на 32-х розрядних архітектур - 32 біта. 
Але варто зазначити, що реалізація не така проста, як здається. Існує лічильник довжиною 64 біта для всіх архітектур, і носить назву - jiffies_64. 
В ході ініціалізації ця змінна просто прирівнюється до jiffies. Таким чином, для 32-розрядних архітектур в змінної jiffies молодші 32 біта значення jiffies_64. 
64 біта необхідні для управління ходом часу, так як така змінна практично не переповниться в процесі експлуатації пристрою. 
На 64-розрядних архітектур обидві змінні ідентичні. А яке початкове значення jiffies? Багато джерел говорять, що воно нульове. Але насправді це не так. Якщо звернутися до вихідного коду ядра в бібліотеку jiffies.h 
то можна побачити обьявление макросу:

.. code-block:: bash

#define INITIAL_JIFFIES ((unsigned long)(unsigned int) (-300*HZ))

це говорить про те, що початкове значення jiffies  здвинено на 5 хвилин відносно (до) нуля. Зроблено для уникнення помилок званими в исходниках як wrap bugs

**Використані бібліотеки**


* ``<linux/module.h>`` - потрібна для всіх модулів   
* ``<linux/moduleparam.h>`` - для використання макросів параметрів     
* ``<linux/kernel.h>`` - заголовки ядра    
* ``<linux/init.h>`` використовується для ініціалізації та деініціалізації    
* ``<linux/jiffies.h>`` лічильник   


**Використані макроси та функції**


``MODULE_DESCRIPTION`` макрос для опису модуля    

``MODULE_AUTHOR`` автор модуля    

``MODULE_VERSION`` версія модуля    

``MODULE_LICENSE`` тип ліцензії  

``module_param`` передача параметрів в модуль    

``MODULE_PARM_DESC`` опис параметра

``printk`` виведення інформації в лог ядра

``jiffies_delta_to_msecs`` розрахунок проміжку часу    



Висновки
---------

в результаті виконання лабораторнрої роботи було налаштовано середу для збірки linux ядра, зібрано мінімальне ядро linux та набір user space утиліт, емуляція поводилася на емуляторі qemu . Також було створено та протестовано власний модуль ядра.(Protocol was taken from Yesich Dmitro's work, because it's appropriate for this laboratory work).
 Приклад роботи власного модуля:

.. code-block:: bash

 / # insmod /mnt/lab_1.ko
[   97.736165] lab_1: loading out-of-tree module taints kernel.
[   97.760036] username was'nt defined !!!
[   97.760584] Hello, $username!
[   97.760584] jiffies = 4294765078
/ # [   97.774994] insmod (93) used greatest stack depth: 13720 bytes left
rmmod lab_1
[  206.754433] Long live the Kernel! Working time = 108 sec



Тестування створеного модуля ядра проводилось двічі в першому випадку ядру не було передано параметрів, і в цьому випадку згідно з завданням модуль повідомляє про те що параметер ``username`` не заданий виводячи відповідне сповіщення в лог ядра з лог рівнем ``KERN_WARNING``, а замість імʼя користувача виводить :``$usrname``. При закритті модуля в лог ядра виводиться жартівлива фраза та відображається час роботи.