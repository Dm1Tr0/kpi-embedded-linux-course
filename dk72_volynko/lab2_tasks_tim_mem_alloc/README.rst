=================================================
**Лабораторна робота №2 засоби відкладеної роботи: тасклети таймери**
=================================================

Завдання
---------------------------------------------------------

* ознайомитись з зазначеною документацією
* на основі отриманих знань створити модуль  ядра що приймати 2 параметри з командної строки cnt та delay. При запуску init молдуль повинен з початку вивести поточне зеначення jiffies потім потрібно запустити тасклет 
що зробить те саме. Далі потрібно запустити таймер що повторно запуститься cnt разів із затримкою delay 

Хід роботи
----------------------------------------------------------

**Написання модуля ядра**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Згідно з отриманим завданням було створено модуль ядра що приймає cnt та delay. Цім параметрам було завше задано значення ``NULL`` щоб позначити що їх значення ще не було задано
далі була створена функція тасклету що виконує поставлену в завданні задачу, по перериванню таймера виконується функція що рекурсивно перезапускає таймер змінюючи значення ``expiers`` поля структури 
при цьому перевіряє кількість запусків лічильника при досьягненні значення cnt лічильник престає модифікуватись. В exit функції з початку відбувається припинення роботи тасклету функцією ``tasklet_kill()`` тому що при використанні цієї функції під час відпрацювання ``tasklet_handler``-у його виконання не переривається 
а доводитсься до кінця, ``tasklet_kill()`` просто забороняє подальший ``scheduling`` цього тасклету. Для деалокації було створено окрему функцію та структуру хоча без цього можна було цілком обійтись це було створено для демонстрації на мою думку оптимального варіанту деалокації великої кількості пам'яті, сенс використання структури при деалокації пам'яті полягає в тому що 
при алокації певної змінної це позначається в спеціальному бітовому полі а потім функція деалокування просто зчитує бітові поля та деалокує відповідні змінні. 
 
З початку було запущено модуль без вхідних параметрів, модуль відреагував на це відповідним чином, вказавши що параметер не задано та не запустившись указуючи на те що 
відсутні вхідні параметри. далі запускаємо модуль ще раз тільки вже з параметрами в лог ядра виводиться значення jiffies з хендлера тасклету та з init функції при завершенні 
роботи модулю в лог відображаються всі значення таймеру які було занесено до масиву, відображається деоалокація масиву та виводиться значення я jiffies в кінці роботи.

Висновки
------------
В результаті роботи було створено свій модуль ядра, роботу та структуру якого описано вище, Jiffies в init та tasklet відрізняються,
тому що від початку ініціалізації і до ``botom half`` де і запускається хендлер тасклету прохходить багато часу,  GFP_KERNEL використовується чререз те 
що ми алокуємо пам'ять в процеісі а не в скедюалері тобто можемо дати можливість процесу поспати чекаючи звільнення простору для алокації пам'яті. використання данного флагу 
при алокації пам'яті в скедюалері може призвести до дедлоку. При delay рівним нулю таймер буде
відпрацьовувати з мінімальною затримкою, зазвичай це 1 такт.
