=================================================
**Лабораторна робота №1 Введення в розробку модулів ядра**
=================================================


Завдання:
---------------
* Підротувати оточення для збірки ядра
* зібрати мінімальне ядро Linux
* зібрати мінімальний набір user-spae утиліт
* зібрати перший модуль ядра на запустити його на зібраному ядрі
* створити власний модуля ядра 

Хід роботи:
------------------
**Налагодження середи розробки**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

для збірки ядра та емуляції ядра потрібно завантажити наступні пакети (групи пакетів):
* bsase-devel - група пакетів які використовуються системами збірки ядра 
* qemu та qemu-arch-extra - емулятор на якому буде запускатися ядро 
* bc та cpio потребуються системою зборки ядра 

.. code-block:: bash

 sudo pacman -S base-devel qemu qemu-arch-extra bc cpio

**Збірка та запуск власного модуля***
~~~~~~~~~~~~~~~~~~~~~~~~~~
Після встановлення всього необхідного устаткування для відлагодження та запуску модулю ядра, було почато модернізацію коду програми.
При наступних змінах та дослідженні коду програми, було знайдено визначення основних використаних функцій та інших інструментів у програмі:

``printk``  - одна з найбільш широко відомих функцій ядра Linux. Це стандартний інструмент для друку повідомлень і,
 як правило, найпростіший спосіб відстеження і улагодження. По суті це все тей же `pritf`, який має функціональні відмінності.

``jiffies`` - глобальна змінна, яка містить кількість тактів, що сталися з моменту завантаження системи. 
При завантаженні ядро ініціалізує змінну до нуля, і вона збільшується на одиницю при кожному перериванні таймера. 
Таким чином, оскільки є переривання таймера HZ в секунду, є HZ `jiffies` в секунду. Таким чином, час безвідмовної роботи
системи становить jiffies / HZ секунд.

``__init, __exit`` -  Макрос ``__init`` призводить до того, що функція init відкидається, а її пам'ять звільняється
після завершення функції init для вбудованих драйверів, але не для завантажуваних модулів. Якщо ви думаєте про те,
коли викликається функція init, це цілком логічно. Існує також ``__initdata`, який працює подібно до ``__init``, 
але для змінних init, а не для функцій. Макрос __exit викликає пропуск функції, коли модуль вбудований в ядро, і, 
як і __exit, не впливає на завантажувані модулі. Знову ж таки, якщо врахувати, коли запускається функція очищення, 
це має повний сенс; вбудовані драйвери не потребують функції очищення, тоді як завантажувані модулі - це потрібно.


Наступним кроком буде безпосередньо збирання модулю ядра. Для цього необхібно було виконати команду ``make modules``.
Далі необхідно запустити ядро за допомогою QEMU. В QEMU створюємо нову директорії та вмонтовуємо в неї перший розділ диску.
За допомогою функції ``insmod`` загружаємо та перевіряємо роботу нашого модулю. Щоб вигрузити модуль необхідно застосувати
функцію ``rmmod``. Після вигрузки модулю можна ще раз його загрузити. Для перевірки, чи є загружений модуль варто застосувати
функцію ``lsmod``.


**Приклад роботи власного модуля:**

.. code-block:: bash

/ # insmod /mnt/lab1_mod.ko 
[  349.376192] username wasn`t passed as a parameter
[  349.377675] Hello, $usrname!
[  349.377675] jiffies = 4295016693
/ # lsmod
lab1_mod 16384 0 - Live 0xffffffffc029e000 (O)
/ # rmmod lab1_mod
[  355.976850] god save the Kernel!
[  355.976850] work time mnt/mymode.ko : 6 sec
/ # insmod /mnt/lab1_mod.ko usrname="NazarVolynko"
[  364.242742] Hello, NazarVolynko!
[  364.242742] jiffies = 4295031557
/ # 


**Використані бібліотеки**


* ``<linux/module.h>`` - потрібна для всіх модулів   
* ``<linux/moduleparam.h>`` - для використання макросів параметрів     
* ``<linux/kernel.h>`` - заголовки ядра    
* ``<linux/init.h>`` використовується для ініціалізації та деініціалізації    
* ``<linux/jiffies.h>`` лічильник   


**Використані макроси та функції**


``MODULE_DESCRIPTION`` макрос для опису модуля    

``MODULE_AUTHOR`` автор модуля    

``MODULE_VERSION`` версія модуля    

``MODULE_LICENSE`` тип ліцензії  

``module_param`` передача параметрів в модуль    

``MODULE_PARM_DESC`` опис параметра

``printk`` виведення інформації в лог ядра

``jiffies_delta_to_msecs`` розрахунок проміжку часу.
    


Висновки:
-------------

  В ході виконання лабораторної роботи було протестовано середовище для збірки 
мінімального Linux ядра, проемульовано в емуляторі QEMU , створено та протестовано 
найпростіший власний модуль по виводу імені користувача та часу роботи між
init та exit. 

  Спершу було протестовано модуль, не передаючи туди параметр usrname, тобто без введеного імені користувача. 
Ядро вивело відповідну фразу "username wasn`t passed as a parameter" , тобто сповістило, що ім'я користувача не введено. 
Після цього було здійснено вихід з ядра. При цьому у консоль виведено специфічну строку та час роботи між макросами. 
Таку ж саму операцію проведено без передачі параметру. 

  Потім було здійснено тестування, при якому було введено ім'я користувача ``usrname="NazarVolynko"`` і програма прийняла
ім'я користувача і вивела привітання до разом з даним іменем.
