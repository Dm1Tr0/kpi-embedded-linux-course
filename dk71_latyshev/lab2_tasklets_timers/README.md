
Лабораторна робота №2
====
Тема: Робота з таймерами та тасклетами
====
Завдання:
===
  - Ознайомитися з таймерами та тасклетами;
  - Написати модуль ядра, який буде приймати на вхід параметри `cnt` та `delay`
    - `cnt` відповідає за кількість циклів відпрацювання тамера
    - `delay` відповідає за затримку між двома відпрацюваннями таймера;
  - При `__init`, записати лог ядра значення `jiffies`
    - після цього викликати тасклет, для запису знаечення `jiffies` в лог ядра;

Хід роботи:
====

Таймери або таймери ядра - дуже важливі для управління потоку часу в коді ядра. Код ядра часто потребує затримок у виконанні деяких функцій.

Тасклети - це структури відкладеного виконання, які ви можете запланувати на виконання у зареєстрованих функціях.
Обробник переривань виконує невеликий обсяг робіт, а потім планує тасклети, які будуть виконані у нижній половині.

Для виконання завдання потрібно зберігати значення `jiffies` в масиві, для того щоб показати правильну роботу таймера.
Для роботи з масивов потрібно виділити пам'ять, для виділення памяті існує багато функцій, але в нашому випадку підійде `kzalloc` або `kmalloc`.
Ці дві функції призначені для виділення пам'яті не більше "сторінки". 

Для запуску модуля потрібно спочатку скомпілювати його:
`make modules

Запускаємо ядро за допомогою QEMU:
`qemu-system-x86_64 -no-kvm -m 512M -smp 4 -kernel "<bzImage path>" -initrd "<path BusyBox shell utilits .gz>" \
                    -append "console=ttyS0" -nographic \
                    -drive file=fat:rw: ./lab2_tasklets_timers <path to module>,format=raw,media=disk`
                    
Підготовчі дії:
`mkdir mnt`
`mount -t vfat /dev/sda1 /mnt`

Запуск модуля:
`insmode /mnt/<lab_2.ko>`

Вигрузка модуля:
`rmmod <module_name>`

Висновки:
===

В ході виконання лабараторної роботи було розроблено простий модуль ядра, який використовує таймери та тасклети.
Було отримано такі дані при не вказуванні параметру:

```
/ # insmod /mnt/lab_2.ko
[   55.088405] lab_2: loading out-of-tree module taints kernel.
[   55.101162] !! Invalid value cnt < 0 
insmod: can't insert '/mnt/lab_2.ko': invalid parameter
[   55.146207] insmod (93) used greatest stack depth: 13720 bytes left
```


При вказуванні `cnt=8` та `delay=10`:

```
/ # insmod /mnt/lab_2.ko cnt=8 delay=10
[   79.530493] !! Nice --> cnt > 0 
[   79.530965] !! Nice --> delay > 0
[   79.531581] !! 10 msec is our delay 
[   79.531938] !! it is equal to 10 jiffies
[   79.532482] !! Init --> jiffies is 4294746847
[   79.533019] !! Tasklet --> jiffies is 4294746848
```

Вимкнення модуля:

```
/ # rmmod lab_2.ko
[  113.875870] !! Exit value --> jiffies is 4294781190
[  113.876788] !! My Array element 0 = 4294746859
[  113.877299] !! My Array element 1 = 4294746870
[  113.877665] !! My Array element 2 = 4294746882
[  113.877665] !! My Array element 3 = 4294746897
[  113.877665] !! My Array element 4 = 4294746914
[  113.879561] !! My Array element 5 = 4294746929
[  113.880105] !! My Array element 6 = 4294746940
[  113.893431] !! My Array element 7 = 4294746953
[  113.894009] GG WP Kernel!
```



В роботі було використано виділення памя'ті з використанням прапору `GFP_KERNEL`, так як наша програма не  є особливо важливою в роботі, тому вона може засипати. 
Для того, щоб отримувати резервну пам'ять портібно виикористовувати прапор `GFP_ATOMIC`, що виключає можливість засипати. Також можливо поєднувати різні прапори через симовл `|`.

1.jiffies, яке друкується в init і яке виводить тасклет відрізняється, через те що ці операції відбуваються не одночасно.
2.При виділенні пам'яті використовувався флаг GFP_KERNEL тому що`GFP_KERNEL` в кінцевому результаті викликає __get_free_pages. 
Функція виконує системний виклик від імені процеса. Використання GFP_KERNEL означає що kmalloc може помістити поточний процес в сон для очікування сторінки пам'яті в разі її відсутності.
3.При delay = 0 Таймер буде викликатися з мінімально допустимою затримкою.

